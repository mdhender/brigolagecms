// brigolagecms/cmd/ddltogo/ddltogo.go
//
// Copyright (c) 2020 Michael Henderson
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.

// Package main implements a utility to convert Postgresql DDL files to Go types.
package main

import (
	"fmt"
	"log"
	"os"
	"path"
	"strings"
	"time"
)

func main() {
	ddlFile := "D:/GoLand/brigolagecms/cmd/ddltogo/data/bricolage.ddl"
	if val := os.Getenv("POSTGRESQL_DDL"); val != "" {
		ddlFile = val
		fmt.Printf("[ddltogo] %-30s == %q\n", "POSTGRESQL_DDL", val)
	}

	ddlFile = path.Clean(ddlFile)
	ddlPath := path.Dir(ddlFile)
	fmt.Printf("[ddltogo] %-30s == %q\n", "DDL_PATH", ddlPath)
	ddlFile = path.Base(ddlFile)
	fmt.Printf("[ddltogo] %-30s == %q\n", "DDL_File", ddlFile)

	if err := os.Chdir(ddlPath); err != nil {
		fmt.Printf("%+v\n", err)
		os.Exit(2)
	}
	fmt.Printf("[ddltogo] %-30s == %q\n", "CWD", ddlPath)

	fmt.Printf("// Code generated by %q on %s; DO NOT EDIT.\n\n", "ddltogo", time.Now().UTC().Format("2006-01-02:15:04:05 UTC"))

	tokens := Tokenize(ddlFile)

	// validate that the parentheses are balanced
	type parenPos struct {
		line, col int
	}
	var parenStack []parenPos
	for _, t := range tokens {
		switch t.Kind {
		case TParenLeft:
			parenStack = append(parenStack, parenPos{line: t.Line, col: t.Col})
		case TParenRight:
			if len(parenStack) == 0 {
				log.Fatalf("%d:%d: unexpected ')' in input\n", t.Line, t.Col)
			}
			parenStack = parenStack[:len(parenStack)-1]
		}
	}
	if len(parenStack) != 0 {
		pos := parenStack[len(parenStack)-1]
		log.Fatalf("%d:%d: unclosed '(' in input\n", pos.line, pos.col)
	}

	nodes := parse(tokens)
	if nodes == nil {
		log.Fatal("what?")
	}
	for _, node := range nodes {
		switch node.Kind {
		case NAggregate:
			// fmt.Printf("// create aggregate %s\n", node.Aggregate.Name)
		case NComment:
			for _, t := range node.Comment.Val {
				switch t.Kind {
				case TCComment:
					for _, line := range strings.Split(string(t.Val), "\n") {
						fmt.Printf("// %4d: %s\n", t.Line, line)
					}
				case TComment:
					fmt.Printf("// %s\n", string(t.Val))
				}
			}
		case NFunction:
			// fmt.Printf("// create function %s\n", node.Function.Name)
		case NIndex:
			// fmt.Printf("// create index %s\n", node.Index.Name)
		case NSequence:
			name, start := node.Sequence.Name, node.Sequence.Start
			fmt.Printf("// create sequence %s\n", name)
			fmt.Printf("// start %s\n", start)
			fmt.Printf("type %s struct {\n", name)
			fmt.Printf("    Val int\n")
			fmt.Printf("}\n\n")
			fmt.Printf("func new_%s() *%s {\n", name, name)
			fmt.Printf("    return &%s{Val: %s}\n", name, start)
			fmt.Printf("}\n\n")
			fmt.Printf("// CurrVal returns the current value in the sequence.\n")
			fmt.Printf("func (seq *%s) CurrVal() int {\n", name)
			fmt.Printf("    return seq.Val\n")
			fmt.Printf("}\n\n")
			fmt.Printf("// NextVal returns the next value in the sequence.\n")
			fmt.Printf("func (seq *%s) NextVal() int {\n", name)
			fmt.Printf("    seq.Val = seq.Val + %s\n", node.Sequence.Incr)
			fmt.Printf("    return seq.Val\n")
			fmt.Printf("}\n\n")
		case NTable:
			name := node.Table.Name
			fmt.Printf("// create table %s\n", name)
			for _, cons := range node.Table.Constraints {
				fmt.Printf("// constraint %s\n", cons.Name)
				for _, key := range cons.PrimaryKey.Keys {
					fmt.Printf("//    pk(%s)\n", key)
				}
				if cons.Check.Is {
					fmt.Printf("//    check %s\n", cons.Name)
					for _, t := range cons.Check.Actions {
						fmt.Printf("//        %s\n", string(t.Val))
					}
				}
			}
			fmt.Printf("type %s struct {\n", name)
			hasChecks, hasDefaults := false, false
			for _, col := range node.Table.Columns {
				name := col.Name
				if name == "type" {
					name = "ttypee"
				} else if name == "ttimestamp" {
					name = "timestamp"
				}

				if col.Constraints != nil {
					for _, cons := range col.Constraints {
						if cons.Check.Is {
							hasChecks = true
						}
					}
				}
				if col.Default != nil {
					hasDefaults = true
				}

				switch col.Kind {
				case NColumnBoolean:
					fmt.Printf("    %s bool\n", name)
				case NColumnChar:
					fmt.Printf("    %s string // char(%s)\n", name, col.Width)
				case NColumnInteger:
					fmt.Printf("    %s int // integer\n", name)
				case NColumnText:
					fmt.Printf("    %s []byte // text, like a blob\n", name)
				case NColumnTimestamp:
					fmt.Printf("    %s time.Time // timestamp\n", name)
				case NColumnVarchar:
					fmt.Printf("    %s string // varchar(%s)\n", name, col.Width)
				default:
					fmt.Printf("    %s unknown // %v\n", name, col.Kind)
				}
			}
			fmt.Printf("}\n\n")
			fmt.Printf("func new_%s() *%s {\n", name, name)
			if !hasDefaults {
				fmt.Printf("    o := %s{}\n", name)
			} else {
				fmt.Printf("    o := %s{\n", name)
				for _, col := range node.Table.Columns {
					name := col.Name
					if name == "type" {
						name = "ttypee"
					} else if name == "ttimestamp" {
						name = "timestamp"
					}

					if col.Default != nil {
						switch col.Default.Kind {
						case "boolean":
							fmt.Printf("        %s: %s,\n", name, col.Default.Val)
						case "generator":
							fmt.Printf("        %s: 0, // %s.NextVal(),\n", name, col.Default.Val[1:len(col.Default.Val)-1])
						case "number":
							fmt.Printf("        %s: %s,\n", name, col.Default.Val)
						case "timestamp":
							if col.Default.Val == "current_timestamp" {
								fmt.Printf("        %s: time.Now(),\n", name)
							} else {
								fmt.Printf("        %s: %s,\n", name, col.Default.Val)
							}
						case "text":
							if col.Kind == NColumnTimestamp && col.Default.Val == "'timeofday()::timestamptz'" {
								fmt.Printf("        %s: time.Now(),\n", name)
							} else {
								fmt.Printf("        %s: %q,\n", name, col.Default.Val[1:len(col.Default.Val)-1])
							}
						default:
							fmt.Printf("        %s: %s %s,\n", name, col.Default.Kind, col.Default.Val)
						}
					}
				}
				fmt.Printf("    }\n")
			}
			if hasChecks {
				for _, col := range node.Table.Columns {
					for _, cons := range col.Constraints {
						if cons.Check.Is {
							fmt.Printf("    // check %s (", col.Name)
							for _, t := range cons.Check.Actions {
								a := string(t.Val)
								if a == "current_timestamp" {
									a = "time.Now()"
								}
								fmt.Printf(" %s ", a)
							}
							fmt.Println(")")
						}
					}
				}
			}
			fmt.Printf("    return &o\n")
			fmt.Printf("}\n\n")
		}
	}
}
